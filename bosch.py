import numpy as np
from scipy.constants import G
from astropy.constants import M_sun

import general as ge


class bosch(object):
    """ Class for generating a potential for a spherical dark matter halo, 
        using the data generated by the model of van den Bosch (2014). 

        Attributes:

            fName:  The name of the file containing the data generated by the 
                    model of van den Bosch. The data should be generated using 
                    the code provided at: 
                    http://www.astro.yale.edu/vdbosch/PWGH.html
            
            M0:     The virial mass of the dark matter halo at current times
                    (redshift 0) in units of solar masses.
            
            data:   The loaded data from the text file; the data is stored in 
                    a 2D numpy array. For more information on which data is 
                    stored, see the README file generated using the code.
            
            red:    The redshift values at which the properties of the dark 
                    matter halo are computed.
            
            mass:   The virial mass of the dark matter halo in units of solar 
                    masses, computed at the redshifts given by red.
            
            conc:   The concentration of the halo (r_vir / r_s) at the given 
                    redshifts.
            
            time:   The lookback time corresponding to the redshift values in 
                    years.
    """
    
    def __init__(self, fName, M0):
        """ Initializing the potential
        
            Input:
                fName   (string)
                M0      (float)
        
            Returns:
                bosch   (object)
        """
        
        self.fName = fName
        self.M0 = M0
        
        data = self.load_data()                         # Loading data
        
            # Unpacking data
        self.red = data[:,1]                            # Redshift
        self.mass = np.power(10, data[:,3]) * self.M0   # Virial mass
        self.conc = data[:,6]                           # Concentration
        self.time = data[:,2] * 1e9                     # Lookback time (yr)
    
    
    def load_data(self):
        """ Loading data from a generated data file 

            Input:
                -
            
            Returns:
                data:   array containing the properties of the dark matter 
                        halo (2D numpy array).
        """
        
        with open(self.fName) as f:                     # Opening data
            data = np.loadtxt((x.replace('     ', '  ') for x in f))
        return data
    
    
    def vir_rad(self, *args):
        """ Find the virial radius (r_vir) as function of redshift

            Input:
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.
            
            Returns:
                The virial radius as function of redshift (numpy array).
        """
        
        red = self.red                                  # Redshift
        deltaC = ge.crit_vir_dens(red)                  # Delta_c
        hubble = ge.hubble_para(red, *args)             # Hubble parameter
        
        hUnits = hubble * 1e3/3.0857e22                 # Units: s-1
        
        num = 2 * G * self.mass * M_sun.value
        denom = deltaC * np.power(hUnits, 2)
        
        return np.power(num / denom, 1/3)
    
    
    def rS(self, *args):
        """ Find the scale length (r_s) as function of redshift.

            Input:
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.
            
            Returns:
                The scale radius as function of redshift (numpy array).
        
        """
        return self.vir_rad(*args) / self.conc
    
    def rhoS(self, *args):
        """ Find the density at scale radius (rho_s) as function of redshift.

            Input:
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.
            
            Returns:
                The virial radius as function of redshift (numpy array).
        """
        
        conc = self.conc                                    # Concentration
        const = 16 * np.pi * np.power(self.rS(*args), 3)    # Constant term
        brack = np.log(1 + conc) - conc / (1 + conc)        # Bracket term
        
        return self.mass * M_sun.value / (const * brack)
    
    def find_z_ind(self, zV):
        """ Input a redshift and find the indices corresponding to the closest 
            redshift value(s) of the generated data. If zV is an array then 
            the closest indices for all the redshift values are determined and 
            returned.

            Input:
                zV:     The redshift value(s) for which the closest index has 
                        to be found (float or numpy array).
            
            Returns:
                The indices corresponding to the closest redshift values 
                (integer or numpy array).
        """
        
        if type(zV) != np.ndarray and type(zV) != list and type(zV) != tuple:
            return ge.find_closest(self.red, zV)[0]
        
        return np.asarray([ge.find_closest(self.red, z)[0] for z in zV])
    
    def rs_rhos_at_z(self, zV, *args):
        """ Find the scale radius (r_s) and the density at the scale radius 
            (rho_s) for a given redshift value. This is done by finding the 
            closest redshift value to the input redshift value(s), NOT by 
            interpolating.

            Input:
                zV:     redshift(s) at which r_s and rho_s will be determined
                        (float or numpy array).
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.
            
            Returns:
                Value of r_s at zV (float or numpy array).
                Value of rho_s at zV (float or numpy array).
        """
        zInd = self.find_z_ind(zV)
        return self.rS(*args)[zInd], self.rhoS(*args)[zInd]
    
    
    def mass_at_r(self, zV, r, *args):
        """ The mass of the dark matter halo as function of distance from the 
            center of the dark matter halo at a given redshift.
        
            Input:
                zV:     redshift(s) at which the mass as function of radius
                        is determined (float or numpy array).
                r:      the distances from the center of the halo at which 
                        the mass will be calculated (float or numpy array).
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.

            Returns:
                mass as function of r and z (float or numpy array (1D or 2D))
        """
        
        rS, rhoS = self.rs_rhos_at_z(zV, *args)         # r_s and rho_s
        
        mass = [rhoS[i] * rS[i] * (np.log(1+r/rS[i]) - r / (rS[i] + r))
                for i in range(len(rS))]
        
        return 16 * np.pi * np.asarray(mass)
    
    
    def simp_profile(self, x):
        """ The NFW profile density profile for the dark matter halo. This 
            function gives rho/rho_s as function of r/r_s. Therefore you do 
            not need to specify the parameters r_s and rho_s. Moreover, this 
            profile is time independent.

            Input:
                x:      r/r_s values, dimensionless (numpy array).
            
            Returns:
                rho/rho_s for the given x values (numpy array).
        """
        return 4 / (x * np.power(1+x, 2))
    
    def nfw_profile(self, zV, r, *args):
        """ A time dependent NFW density profile. With the input of the 
            desired redshift value(s), a time dependent density profile 
            as function of radius is output. r_s and rho_s are determined 
            using the model of van den Bosch.
            
            Input:
                zV:     the redshift values at which the density profile 
                        is computed (float or numpy array).
                r:      distance from the center of the halo (float or 
                        numpy array).
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.

            Returns:
                time dependent NFW profile (float or numpy array(1D or 2D))
        """
        
        zInd = self.find_z_ind(zV)                          # Selecting z ind
        
        rS = self.rS(*args)                                 # r_s
        rhoS = self.rhoS(*args)                             # rho_s
        
        if type(zInd) != np.ndarray:                        # Single z value
            denom = r * np.power(1 + r/rS[zInd], 2) / rS[zInd]
            return 4 * rhoS[zInd] / denom
        
        selrS, selrhoS = rS[zInd], rhoS[zInd]               # Slicing lists
        
                    # Multiple z values
        frac = [selrhoS[ind] / (r * np.power(1 + r/selrS[ind], 2) / selrS[ind]) 
                for ind in range(len(selrS))]
        
        return 4 * np.asarray(frac)
    
    def pot_nfw(self, zV, r, *args):
        """ The gravitational potential corresponding to the NFW 
            density profile. This is obtained by solving the Poisson 
            equation. For the NFW profile there exists an analytical 
            solution.
        
            Input:
                zV:     the redshift values at which the potential is 
                        computed (float or numpy array).
                r:      distance from the center of the halo (float or 
                        numpy array).
                *args:  Cosmological parameter values H0 and omegaM0
                        The input should be the same as used in the 
                        generation of the data using the code of van 
                        den Bosch. Default: H0=67.66, omegaM0=0.3089.

            Returns:
                gravitational potential (float or numpy array(1D or 2D))
        """
        
        rhoS = self.rhoS(*args)                             # rho_s
        rS = self.rS(*args)                                 # r_s
        
        zInd = self.find_z_ind(zV)                          # Finding correct z
        selrS, selrhoS = rS[zInd], rhoS[zInd]               # Slicing lists
        
        if type(zInd) != np.ndarray:                        # Single z value
            part1 = -16 * np.pi * G * selrhoS * selrS * selrS
            part2 = np.log(1 + r/selrS) / (r/selrS)
            return part1 * part2
        
            # Multiple z values
        part1 = -16 * np.pi * G * selrhoS * selrS * selrS       # First part
        part2 = [np.log(1 + r/rsV) / (r/rsV) for rsV in selrS]  # Second part
        
        phi = [part1[ind] * part2[ind] for ind in range(len(zInd))] # Potential
        
        return np.asarray(phi)

